/*
 * test_print_psbt_fragments.c
 *
 * Generates UR fragments from PSBT files and prints them to stdout.
 * This tool is designed for cross-implementation testing where fragments
 * generated by C encoder are decoded by other implementations (e.g., Python).
 *
 * Usage: ./test_print_psbt_fragments [psbt_file]
 *   If no file specified, processes all .psbt.bin files in tests/test_cases/PSBTs/
 */

#include "../../src/ur_encoder.h"
#include "../../src/types/psbt.h"
#include "../test_utils.h"
#include <dirent.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Print fragments for one PSBT file
static bool print_fragments_for_file(const char *filename) {
  fprintf(stderr, "\n=== Processing: %s ===\n", filename);

  // Read PSBT binary data from file
  size_t psbt_len = 0;
  uint8_t *psbt_bytes = read_binary_file(filename, &psbt_len);

  if (!psbt_bytes) {
    fprintf(stderr, "Error: Failed to read file\n");
    return false;
  }

  fprintf(stderr, "PSBT size: %zu bytes\n", psbt_len);

  // Create PSBT object
  psbt_data_t *psbt = psbt_new(psbt_bytes, psbt_len);
  if (!psbt) {
    fprintf(stderr, "Error: Failed to create PSBT object\n");
    free(psbt_bytes);
    return false;
  }

  // Convert PSBT to CBOR
  size_t cbor_len = 0;
  uint8_t *cbor_data = psbt_to_cbor(psbt, &cbor_len);

  if (!cbor_data) {
    fprintf(stderr, "Error: Failed to convert PSBT to CBOR\n");
    psbt_free(psbt);
    free(psbt_bytes);
    return false;
  }

  fprintf(stderr, "CBOR size: %zu bytes\n", cbor_len);

  // Create UREncoder
  size_t max_fragment_len = 200; // Reasonable fragment size for testing
  ur_encoder_t *encoder = ur_encoder_new("crypto-psbt", cbor_data, cbor_len,
                                         max_fragment_len, 0, 10);

  if (!encoder) {
    fprintf(stderr, "Error: Failed to create encoder\n");
    free(cbor_data);
    psbt_free(psbt);
    free(psbt_bytes);
    return false;
  }

  size_t seq_len = ur_encoder_seq_len(encoder);
  bool is_single = ur_encoder_is_single_part(encoder);

  fprintf(stderr, "Encoder configuration:\n");
  fprintf(stderr, "  - Single part: %s\n", is_single ? "yes" : "no");
  fprintf(stderr, "  - Sequence length: %zu\n", seq_len);

  // Generate and print fragments
  // For multi-part, generate extra fragments to test fountain coding
  size_t fragments_to_generate = is_single ? 1 : (seq_len * 2 + 5);

  fprintf(stderr, "Generating %zu fragments...\n", fragments_to_generate);

  for (size_t i = 0; i < fragments_to_generate; i++) {
    char *fragment = NULL;
    if (!ur_encoder_next_part(encoder, &fragment)) {
      fprintf(stderr, "Error: Failed to generate fragment %zu\n", i + 1);
      break;
    }

    // Print fragment to stdout (this is what will be captured)
    printf("%s\n", fragment);
    free(fragment);
  }

  fprintf(stderr, "Successfully generated %zu fragments\n",
          fragments_to_generate);

  // Cleanup
  ur_encoder_free(encoder);
  free(cbor_data);
  psbt_free(psbt);
  free(psbt_bytes);

  return true;
}

int main(int argc, char *argv[]) {
  fprintf(stderr, "============================================================"
                  "==========\n");
  fprintf(stderr, "UR PSBT Fragment Generator for Cross-Implementation Testing\n");
  fprintf(stderr, "============================================================"
                  "==========\n");

  // If specific file provided, process just that one
  if (argc > 1) {
    const char *filename = argv[1];
    fprintf(stderr, "Processing single file: %s\n", filename);

    if (!print_fragments_for_file(filename)) {
      return 1;
    }

    fprintf(stderr, "\n========================================================"
                    "==============\n");
    fprintf(stderr, "Fragment generation complete\n");
    fprintf(stderr, "=========================================================="
                    "============\n");
    return 0;
  }

  // Otherwise, process all test cases
  const char *test_dir = "tests/test_cases/PSBTs";
  DIR *dir = opendir(test_dir);

  if (!dir) {
    fprintf(stderr, "Error: Cannot open test_cases directory: %s\n", test_dir);
    return 1;
  }

  // Collect all .psbt.bin files
  char **test_files = NULL;
  size_t test_count = 0;
  size_t capacity = 10;

  test_files = (char **)malloc(capacity * sizeof(char *));

  struct dirent *entry;
  while ((entry = readdir(dir)) != NULL) {
    // Look for files ending with .psbt.bin
    size_t name_len = strlen(entry->d_name);
    if (name_len > 9 &&
        strcmp(entry->d_name + name_len - 9, ".psbt.bin") == 0) {
      if (test_count >= capacity) {
        capacity *= 2;
        test_files = (char **)realloc(test_files, capacity * sizeof(char *));
      }

      // Build full path
      char *full_path =
          (char *)malloc(strlen(test_dir) + strlen(entry->d_name) + 2);
      sprintf(full_path, "%s/%s", test_dir, entry->d_name);
      test_files[test_count++] = full_path;
    }
  }
  closedir(dir);

  if (test_count == 0) {
    fprintf(stderr, "Error: No .psbt.bin files found in %s\n", test_dir);
    free(test_files);
    return 1;
  }

  fprintf(stderr, "Found %zu test files\n", test_count);

  // Process all test files
  size_t success_count = 0;

  for (size_t i = 0; i < test_count; i++) {
    if (print_fragments_for_file(test_files[i])) {
      success_count++;
    }
    free(test_files[i]);
  }

  free(test_files);

  // Summary
  fprintf(stderr, "\n=========================================================="
                  "============\n");
  fprintf(stderr, "Fragment Generation Summary\n");
  fprintf(stderr, "============================================================"
                  "==========\n");
  fprintf(stderr, "Total test files: %zu\n", test_count);
  fprintf(stderr, "Successfully processed: %zu\n", success_count);
  fprintf(stderr, "Failed: %zu\n", test_count - success_count);
  fprintf(stderr, "============================================================"
                  "==========\n");

  return (success_count == test_count) ? 0 : 1;
}

/*
 * test_print_fragments.c
 *
 * Generates UR fragments from test case files and prints them to stdout.
 * This tool is designed for cross-implementation testing where fragments
 * generated by C encoder are decoded by other implementations (e.g., Python).
 *
 * Usage: ./test_print_fragments [test_case_file]
 *   If no file specified, processes all .UR_object.txt files in
 * tests/test_cases/
 */

#include "../../src/ur_encoder.h"
#include <ctype.h>
#include <dirent.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Helper: Convert hex string to bytes
static bool hex_to_bytes(const char *hex, uint8_t **bytes_out,
                         size_t *len_out) {
  // Skip "hex:" prefix if present
  if (strncmp(hex, "hex:", 4) == 0) {
    hex += 4;
  }

  // Count hex digits (skip whitespace and newlines)
  size_t hex_len = 0;
  for (const char *p = hex; *p; p++) {
    if (isxdigit(*p)) {
      hex_len++;
    }
  }

  if (hex_len % 2 != 0) {
    fprintf(stderr, "Invalid hex string (odd length)\n");
    return false;
  }

  size_t byte_len = hex_len / 2;
  uint8_t *bytes = (uint8_t *)malloc(byte_len);
  if (!bytes) {
    return false;
  }

  size_t byte_idx = 0;
  const char *p = hex;
  while (*p && byte_idx < byte_len) {
    // Skip whitespace
    while (*p && isspace(*p))
      p++;
    if (!*p)
      break;

    // Read two hex digits
    if (!isxdigit(p[0]) || !isxdigit(p[1])) {
      free(bytes);
      return false;
    }

    char hex_byte[3] = {p[0], p[1], 0};
    bytes[byte_idx++] = (uint8_t)strtol(hex_byte, NULL, 16);
    p += 2;
  }

  *bytes_out = bytes;
  *len_out = byte_idx;
  return true;
}

// Helper: Read hex CBOR data from file
static bool read_cbor_from_file(const char *filename, uint8_t **cbor_out,
                                size_t *len_out) {
  FILE *f = fopen(filename, "r");
  if (!f) {
    fprintf(stderr, "Error: Cannot open file: %s\n", filename);
    return false;
  }

  // Read entire file
  fseek(f, 0, SEEK_END);
  long file_size = ftell(f);
  fseek(f, 0, SEEK_SET);

  char *content = (char *)malloc(file_size + 1);
  if (!content) {
    fclose(f);
    return false;
  }

  size_t read_size = fread(content, 1, file_size, f);
  content[read_size] = '\0';
  fclose(f);

  // Convert hex to bytes
  bool success = hex_to_bytes(content, cbor_out, len_out);
  free(content);

  return success;
}

// Print fragments for one test case file
static bool print_fragments_for_file(const char *filename) {
  fprintf(stderr, "\n=== Processing: %s ===\n", filename);

  // Read CBOR data from file
  uint8_t *cbor_data = NULL;
  size_t cbor_len = 0;

  if (!read_cbor_from_file(filename, &cbor_data, &cbor_len)) {
    fprintf(stderr, "Error: Failed to read file\n");
    return false;
  }

  fprintf(stderr, "CBOR data size: %zu bytes\n", cbor_len);

  // Create UREncoder
  size_t max_fragment_len = 200; // Reasonable fragment size for testing
  ur_encoder_t *encoder = ur_encoder_new("crypto-psbt", cbor_data, cbor_len,
                                         max_fragment_len, 0, 10);

  if (!encoder) {
    fprintf(stderr, "Error: Failed to create encoder\n");
    free(cbor_data);
    return false;
  }

  size_t seq_len = ur_encoder_seq_len(encoder);
  bool is_single = ur_encoder_is_single_part(encoder);

  fprintf(stderr, "Encoder configuration:\n");
  fprintf(stderr, "  - Single part: %s\n", is_single ? "yes" : "no");
  fprintf(stderr, "  - Sequence length: %zu\n", seq_len);

  // Generate and print fragments
  // For multi-part, generate extra fragments to test fountain coding
  size_t fragments_to_generate = is_single ? 1 : (seq_len * 2 + 5);

  fprintf(stderr, "Generating %zu fragments...\n", fragments_to_generate);

  for (size_t i = 0; i < fragments_to_generate; i++) {
    char *fragment = NULL;
    if (!ur_encoder_next_part(encoder, &fragment)) {
      fprintf(stderr, "Error: Failed to generate fragment %zu\n", i + 1);
      break;
    }

    // Print fragment to stdout (this is what will be captured)
    printf("%s\n", fragment);
    free(fragment);
  }

  fprintf(stderr, "Successfully generated %zu fragments\n",
          fragments_to_generate);

  // Cleanup
  ur_encoder_free(encoder);
  free(cbor_data);

  return true;
}

int main(int argc, char *argv[]) {
  fprintf(stderr, "============================================================"
                  "==========\n");
  fprintf(stderr, "UR Fragment Generator for Cross-Implementation Testing\n");
  fprintf(stderr, "============================================================"
                  "==========\n");

  // If specific file provided, process just that one
  if (argc > 1) {
    const char *filename = argv[1];
    fprintf(stderr, "Processing single file: %s\n", filename);

    if (!print_fragments_for_file(filename)) {
      return 1;
    }

    fprintf(stderr, "\n========================================================"
                    "==============\n");
    fprintf(stderr, "Fragment generation complete\n");
    fprintf(stderr, "=========================================================="
                    "============\n");
    return 0;
  }

  // Otherwise, process all test cases
  const char *test_dir = "tests/test_cases";
  DIR *dir = opendir(test_dir);

  if (!dir) {
    fprintf(stderr, "Error: Cannot open test_cases directory: %s\n", test_dir);
    return 1;
  }

  // Collect all UR_object.txt files
  char **test_files = NULL;
  size_t test_count = 0;
  size_t capacity = 10;

  test_files = (char **)malloc(capacity * sizeof(char *));

  struct dirent *entry;
  while ((entry = readdir(dir)) != NULL) {
    // Look for files ending with .UR_object.txt
    size_t name_len = strlen(entry->d_name);
    if (name_len > 14 &&
        strcmp(entry->d_name + name_len - 14, ".UR_object.txt") == 0) {
      if (test_count >= capacity) {
        capacity *= 2;
        test_files = (char **)realloc(test_files, capacity * sizeof(char *));
      }

      // Build full path
      char *full_path =
          (char *)malloc(strlen(test_dir) + strlen(entry->d_name) + 2);
      sprintf(full_path, "%s/%s", test_dir, entry->d_name);
      test_files[test_count++] = full_path;
    }
  }
  closedir(dir);

  if (test_count == 0) {
    fprintf(stderr, "Error: No UR_object.txt files found in %s\n", test_dir);
    free(test_files);
    return 1;
  }

  fprintf(stderr, "Found %zu test files\n", test_count);

  // Process all test files
  size_t success_count = 0;

  for (size_t i = 0; i < test_count; i++) {
    if (print_fragments_for_file(test_files[i])) {
      success_count++;
    }
    free(test_files[i]);
  }

  free(test_files);

  // Summary
  fprintf(stderr, "\n=========================================================="
                  "============\n");
  fprintf(stderr, "Fragment Generation Summary\n");
  fprintf(stderr, "============================================================"
                  "==========\n");
  fprintf(stderr, "Total test files: %zu\n", test_count);
  fprintf(stderr, "Successfully processed: %zu\n", success_count);
  fprintf(stderr, "Failed: %zu\n", test_count - success_count);
  fprintf(stderr, "============================================================"
                  "==========\n");

  return (success_count == test_count) ? 0 : 1;
}
